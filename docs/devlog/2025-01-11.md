# 2025-01-11 Development Log

## System Architecture Overview

### Key Files and Their Roles

1. Backend Core Files:
```
src/nia/nova/core/
├── endpoints.py         # Main FastAPI endpoints for chat, graph, agents
├── nova_endpoints.py    # Nova-specific endpoints (ask Nova, etc.)
├── app.py              # FastAPI app configuration and router setup
├── dependencies.py     # Dependency injection providers
├── websocket.py        # WebSocket connection management
├── auth.py            # API key validation and permissions
├── error_handling.py  # Error handlers and validation
└── models.py          # Pydantic models for requests/responses
```

2. Frontend Structure:
```
frontend/src/
├── routes/
│   ├── +page.svelte           # Main chat interface
│   └── threads/
│       └── [id]/
│           └── +page.svelte   # Thread detail view
├── lib/
│   ├── services/
│   │   └── chat.ts           # Chat API service
│   └── types/
│       └── chat.ts           # TypeScript types for chat
```

### API Endpoints Overview

1. Chat System Endpoints (/api/chat):
```
POST /threads/create
- Request: ThreadRequest { title, domain?, metadata? }
- Response: ThreadResponse { id, title, domain, messages, created_at, updated_at, metadata }

GET /threads/{thread_id}
- Response: ThreadResponse

POST /threads/{thread_id}/messages
- Request: MessageRequest { content, sender_type, sender_id, metadata? }
- Response: MessageResponse { message, thread_id, timestamp }

GET /threads
- Response: ThreadListResponse { threads, total, timestamp }

POST /threads/{thread_id}/suggest-agents
- Request: { task: string }
- Response: { recommended: string[], confidence: number, explanation: string }
```

2. Nova Specific Endpoints (/api/nova):
```
POST /ask
- Request: { content: string }
- Response: { threadId: string, message: Message }
```

3. WebSocket Endpoint (/api/ws/ws):
```
Message Types:
- ping/pong: Heartbeat
- graph_subscribe: Get initial graph data
- swarm_monitor: Monitor swarm activity
- agent_coordination: Handle agent coordination
- analytics: Process analytics requests

Response Types:
- graph_update: Node/edge updates
- analytics_update: Analytics results
- swarm_update: Swarm activity
- response: Final responses
- error: Error messages
```

### Memory Storage Format

1. Thread Storage:
```typescript
// Store format in memory system
{
    content: {
        data: {
            id: string,
            title: string,
            domain: string,
            messages: Message[],
            created_at: string,
            updated_at: string,
            metadata: Record<string, any>
        },
        metadata: {
            type: "thread",
            domain: string,
            thread_id: string,
            timestamp: string,
            id: string
        }
    },
    memory_type: "episodic",
    importance: number,
    context: {
        domain: string,
        thread_id: string,
        source: string
    }
}
```

2. Message Storage:
```typescript
// Message format
{
    id: string,
    content: string,
    sender_type: string, // "user" | "agent"
    sender_id: string,
    timestamp: string,
    metadata?: Record<string, any>
}
```

### Implementation Notes

1. Chat System:
- Uses two-layer memory system:
  * Episodic (Qdrant): Recent messages, context
  * Semantic (Neo4j): Thread relationships, patterns
- Real-time updates via WebSocket
- Domain-aware thread organization
- Profile-based adaptations

2. Graph Visualization:
- Uses Cytoscape.js
- Real-time updates via WebSocket
- Interactive node details
- Search and filtering capabilities

3. Agent System:
- Dynamic agent spawning
- Team-based organization
- Domain boundary enforcement
- Profile-based adaptation

### UI/UX Implementation

#### Access Levels vs Domains Clarification

Important architectural insight: The system needs to clearly separate two distinct concepts that are currently mixed in the UI:

1. Access Levels (Workspace-Level Organization):
- Personal Workspace: For user's private tasks and data
- Professional Workspace: For business/enterprise tasks
- These should be implemented like Slack workspaces - high-level containers

2. Knowledge Domains (Professional Context Only):
- Specialized verticals: Retail, BFSI, Finance, etc.
- Only exist within Professional workspace
- Represent areas of expertise and knowledge boundaries
- Used for organizing threads and enforcing knowledge boundaries

Current Implementation Issues:
- Personal is incorrectly shown in domain selector
- Domain selector placement needs revision
- Workspace/domain hierarchy needs clarification

Required Changes:
- Move Personal/Professional to workspace-level switches
- Update domain selector to only show knowledge verticals
- Reorganize thread display to reflect proper hierarchy
- Update thread creation flow to handle both contexts

#### Layout and Components:
```
+----------------+------------------+----------------+
|                |                  |                |
| Channels       |   Chat Area      |    Graph      |
| & Threads      |   Messages       |    View       |
|                |   Agent Logs     |               |
|                |                  |               |
+----------------+------------------+----------------+
```

2. Key Features:
- Slack-like chat interface
- Real-time message updates
- Thread management
- Agent team visualization
- Graph-based task tracking
- Domain switching
- Profile preferences

### Next Steps

1. Frontend Priority:
- Implement chat interface components
- Add real-time updates
- Integrate profile adaptations
- Complete thread management

2. Backend Tasks:
- Monitor memory system performance
- Optimize WebSocket connections
- Enhance error handling
- Add more comprehensive logging

3. Testing:
- Add frontend component tests
- Enhance WebSocket testing
- Monitor real system performance
- Document testing patterns

### Notes for Future Development

1. File Organization:
- Keep endpoints.py focused on core routes
- Use nova_endpoints.py for Nova-specific routes
- Maintain clear separation of concerns
- Follow established naming patterns

2. Memory System:
- Use consistent storage format
- Maintain proper metadata
- Respect domain boundaries
- Handle profile adaptations

3. Testing Strategy:
- Use real Neo4j for development
- Simplify mock tests
- Focus on component testing
- Monitor system performance

4. Documentation:
- Keep devlogs updated
- Document key decisions
- Maintain clear API docs
- Update UI/UX notes
